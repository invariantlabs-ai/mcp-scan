import logging
import os

from pydantic import BaseModel

from mcp_scan.inspect import (
    get_mcp_config_per_client,
    inspect_client,
    inspected_client_to_scan_path_result,
)
from mcp_scan.models import (
    CandidateClient,
    ClientToInspect,
    ControlServer,
    ScanError,
    ScanPathResult,
    SkillServer,
    TokenAndClientInfo,
)
from mcp_scan.upload import upload
from mcp_scan.utils import get_push_key
from mcp_scan.verify_api import analyze_machine
from mcp_scan.well_known_clients import get_well_known_clients

logger = logging.getLogger(__name__)


class InspectArgs(BaseModel):
    timeout: int
    tokens: list[TokenAndClientInfo]
    paths: list[str] | None = None


class AnalyzeArgs(BaseModel):
    analysis_url: str
    identifier: str | None = None
    additional_headers: dict | None = None
    opt_out_of_identity: bool = False
    max_retries: int = 3
    skip_ssl_verify: bool = False


class PushArgs(BaseModel):
    control_servers: list[ControlServer]
    skip_ssl_verify: bool = False
    version: str | None = None


async def inspect_pipeline(
    inspect_args: InspectArgs,
) -> list[ScanPathResult]:
    # fetch clients to inspect
    if inspect_args.paths is not None:
        clients_to_inspect = [await client_to_inspect_from_path(path, True) for path in inspect_args.paths]
    else:
        clients_to_inspect = [await get_mcp_config_per_client(client) for client in get_well_known_clients()]

    # inspect
    scan_path_results: list[ScanPathResult] = []
    for i, client_to_inspect in enumerate(clients_to_inspect):
        if client_to_inspect is None and inspect_args.paths is not None:
            scan_path_results.append(
                ScanPathResult(
                    path=inspect_args.paths[i],
                    client=inspect_args.paths[i],
                    servers=[],
                    issues=[],
                    labels=[],
                    error=ScanError(message="File or folder not found", is_failure=False, category="file_not_found"),
                )
            )
            continue
        elif client_to_inspect is None:
            logger.info(
                f"Client {get_well_known_clients()[i].name} does not exist os this machine. {get_well_known_clients()[i].client_exists_paths}"
            )
            continue
        else:
            inspected_client = await inspect_client(client_to_inspect, inspect_args.timeout, inspect_args.tokens)
            scan_path_results.append(inspected_client_to_scan_path_result(inspected_client))
    return scan_path_results


async def inspect_analyze_push_pipeline(
    inspect_args: InspectArgs,
    analyze_args: AnalyzeArgs,
    push_args: PushArgs,
    verbose: bool = False,
) -> list[ScanPathResult]:
    """
    Pipeline the scan and analyze the machine.
    """
    # inspect
    scan_path_results = await inspect_pipeline(inspect_args)

    # analyze
    verified_scan_path_results = await analyze_machine(
        scan_path_results,
        analysis_url=analyze_args.analysis_url,
        identifier=analyze_args.identifier,
        additional_headers=analyze_args.additional_headers,
        opt_out_of_identity=analyze_args.opt_out_of_identity,
        verbose=verbose,
        skip_pushing=bool(push_args.control_servers),
        push_key=get_push_key(push_args.control_servers),
        max_retries=analyze_args.max_retries,
        skip_ssl_verify=analyze_args.skip_ssl_verify,
    )
    # push
    for control_server in push_args.control_servers:
        await upload(
            verified_scan_path_results,
            control_server.url,
            control_server.identifier,
            control_server.opt_out,
            verbose=verbose,
            additional_headers=control_server.headers,
            skip_ssl_verify=push_args.skip_ssl_verify,
            scan_context={"cli_version": push_args.version},
        )

    return verified_scan_path_results


async def client_to_inspect_from_path(path: str, use_path_as_client_name: bool = False) -> ClientToInspect | None:
    if os.path.isdir(os.path.expanduser(path)):
        if os.path.exists(os.path.join(path, "SKILL.md")):
            # split last dir from all other dirs in the path
            last_dir = path.split("/")[-1]
            path_without_last_dir = "/".join(path.split("/")[:-1])
            return ClientToInspect(
                name="not-available" if use_path_as_client_name else path,
                client_path=path_without_last_dir,
                mcp_configs={},
                skills_dirs={
                    path_without_last_dir: [(last_dir, SkillServer(path=path))],
                },
            )
        else:
            candidate_client = CandidateClient(
                name="not-available" if use_path_as_client_name else path,
                client_exists_paths=[path],
                mcp_config_paths=[],
                skills_dir_paths=[path],
            )
            return await get_mcp_config_per_client(candidate_client)
    else:
        candidate_client = CandidateClient(
            name="not-available" if use_path_as_client_name else path,
            client_exists_paths=[path],
            mcp_config_paths=[path],
            skills_dir_paths=[],
        )
        return await get_mcp_config_per_client(candidate_client)
